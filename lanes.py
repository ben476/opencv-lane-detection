# -*- coding: utf-8 -*-
"""road_lane_detection.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1w6xv6v5xuQPmMJMMQ5MZnGlC6F9bsi7Q
"""

#ROAD LANE DETECTION

import cv2
import sys
import numpy as np

def grey(image):
  #convert to grayscale
    image = np.asarray(image)
    return cv2.cvtColor(image, cv2.COLOR_RGB2GRAY)

  #Apply Gaussian Blur --> Reduce noise and smoothen image
def gauss(image):
    return cv2.GaussianBlur(image, (5, 5), 0)

  #outline the strongest gradients in the image --> this is where lines in the image are
def canny(image):
    edges = cv2.Canny(image,50,150)
    return edges

def region(image):
    height, width = image.shape
    #isolate the gradients that correspond to the lane lines
    triangle = np.array([
                       [(100, height), (475, 325), (width, height)]
                       ])
    #create a black image with the same dimensions as original image
    mask = np.zeros_like(image)
    #create a mask (triangle that isolates the region of interest in our image)
    mask = cv2.fillPoly(mask, triangle, 255)
    mask = cv2.bitwise_and(image, mask)
    return image

def display_lines(image: np.ndarray, lines: np.ndarray) -> np.ndarray:
    lines_image = np.zeros_like(image)
    if lines is not None:
    #make sure array length is 2
        if len(lines) != 2:
            return image
        # get middle line by averaging the two lines
        line_one = lines[0]
        line_two = lines[1]
        # average
        line_avg = np.mean( np.array([ line_one, line_two ]), axis=0 ).astype(np.int32)
        to_draw = [line_avg, line_one, line_two]
        print(type(line_avg[0]),type(line_two[0]))
        for line in to_draw:
            x1, y1, x2, y2 = line
            #draw lines on a black image
            # print(x1, y1, x2, y2)
            # try:
            cv2.line(lines_image, (x1, y1), (x2, y2), (255, 0, 0), 10)
            # except:	
            #     print("error", x1, y1, x2, y2)
    return lines_image

def average(image, lines):
    left = []
    right = []

    # only take the two largest lines


    if lines is not None:
      for line in lines:
        # print(line)
        x1, y1, x2, y2 = line.reshape(4)
        #fit line to points, return slope and y-int
        parameters = np.polyfit((x1, x2), (y1, y2), 1)
        # print(parameters)
        slope = parameters[0]
        y_int = parameters[1]
        #lines on the right have positive slope, and lines on the left have neg slope
        if slope < 0:
            left.append((slope, y_int))
        else:
            right.append((slope, y_int))
            
    #takes average among all the columns (column0: slope, column1: y_int)
    right_avg = np.average(right, axis=0)
    left_avg = np.average(left, axis=0)
    #create lines based on averages calculates
    left_line = make_points(image, left_avg)
    right_line = make_points(image, right_avg)
    return np.array([left_line, right_line])

def make_points(image, average):
    # print(average)
    try:
        slope, y_int = average
    except:
        return np.array([0,0,0,0])
    y1 = image.shape[0]
    #how long we want our lines to be --> 3/5 the size of the image
    y2 = int(y1 * 1/5)
    #determine algebraically
    x1 = int((y1 - y_int) // slope)
    x2 = int((y2 - y_int) // slope)
    return np.array([x1, y1, x2, y2])

    # video = cv2.VideoCapture("input.mp4")
video = cv2.VideoCapture(0) # for using CAM

# Exit if video not opened.
if not video.isOpened():
    print("Could not open video")
    sys.exit()

# Read first frame.
ok, frame = video.read()
if not ok:
    print ('Cannot read video file')
    sys.exit()
    
while True:
    # Read a new frame
    ok, frame = video.read()
    if not ok:
        break
        
    # Start timer
    timer = cv2.getTickCount()

    # Calculate Frames per second (FPS)
    fps = cv2.getTickFrequency() / (cv2.getTickCount() - timer);

    # copy = np.copy(frame)
    # edges = cv2.Canny(copy,50,150)

    # cv2.imshow("Tracking", edges)
    # cv2.imshow(isolated)

    # filter to blue lane lines

    blue = cv2.inRange(frame, (140, 70, 0), (255, 160, 80))
    edges = cv2.Canny(blue,50,150)
    # red = cv2.inRange(frame, (0, 0, 50), (50, 50, 255))

    # cv2.imshow("Tracking", red)
    # cv2.imshow("Tracking blue", blue)

    #DRAWING LINES: (order of params) --> region of interest, bin size (P, theta), min intersections needed, placeholder array, 
    blue_lines = cv2.HoughLinesP(edges, 2, np.pi/180, 100, np.array([]), minLineLength=60, maxLineGap=2)
    blue_averaged_lines = average(edges, blue_lines)
    blue_black_lines = display_lines(edges, blue_averaged_lines)
    #taking wighted sum of original image and lane lines image
    blue_lanes = cv2.addWeighted(edges, 0.8, blue_black_lines, 1, 1)

    # red_lines = cv2.HoughLinesP(red, 2, np.pi/180, 100, np.array([]), minLineLength=60, maxLineGap=2)
    # red_averaged_lines = average(copy, red_lines)
    # red_black_lines = display_lines(copy, red_averaged_lines)
    # #taking wighted sum of original image and lane lines image
    # red_lanes = cv2.addWeighted(copy, 0.8, red_black_lines, 1, 1)

    # combine the two images
    # lanes = cv2.addWeighted(blue_lanes, 0.8, red_lanes, 1, 1)


    cv2.imshow("Tracking", blue_lanes)

    # Display FPS on frame
    cv2.putText(frame, "FPS : " + str(int(fps)), (100,50), cv2.FONT_HERSHEY_SIMPLEX, 0.75, (50,170,50), 2);
    # Display result
    # cv2.imshow("Tracking", frame)

    # Exit if ESC pressed
    if cv2.waitKey(1) & 0xFF == ord('q'): # if press SPACE bar
        break
video.release()
cv2.destroyAllWindows()